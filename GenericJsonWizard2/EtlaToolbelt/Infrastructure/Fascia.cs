// --------------------------------------------------------------------------------------------------
//	This code was generated by the ETLA Toolbelt Wizard version 1.0.59.11
//	Generated date: 2021-Mar-04 16:30:31
//
//	Changes to this file will be lost if the code is regenerated.
//	To make changes or additions, rerun the ETLA Toolbelt Wizard after editing T4 templates if required
// --------------------------------------------------------------------------------------------------

namespace GenericJsonSuite.EtlaToolbelt.Infrastructure;

/// <summary>
/// The philosophy behind the ETLA Toolbelt is as follows:	
///  * that using a tool in an application should be made as simple as possible (important)
///  * that there can be many possible implementations of a given tool
///  * that only one implementation is used by an application at any given point in time (important)
///  * that any given application is likely to only use one implementation; and that this should be the default, requiring no extra set-up
///  * that the application does not need to know (indeed, in general should not know) which implementation is being used
///  * that the developers will know at compile time which implementation of each tool is appropriate for their application
///  * that, over time, the appropriate implmentation of a given tool in an application may need to change as the application changes
///  * that having unused tool implementations in application code is wasteful and leads to bloat
/// 
/// The ETLA Toolbelt is probably not appropriate if the situation is different...
///  e.g. use Dependency Injection (Inversion of Control) if multiple implementations are used at the same time
///
/// The idea of the Fascia pattern is that the user programs against a "class contract", i.e. the static methods defined in an abstract class
/// The Fascia class provides a default implementation object; though the implementation object can be changed programmatically 
/// Calls to the Fascia methods are delegated to the implementaion object
/// Any implementation object class must derive from a associated interface in order to allow the delegation to work. 
///
/// The Fascia abstract class below is the base class for all Fascia classes (which should also be abstract)
/// </summary>
public abstract class Fascia<TInterface, TFallback> where TFallback : TInterface, new()
{
    private static readonly object _Lock = new();
    private static TInterface? _Impl;

    /// <summary>The object implementing the functionality defined by the TInterface</summary>
    public static TInterface Implementation
    {
        get { lock (_Lock) { _Impl ??= new TFallback(); return _Impl; } }
        set { lock (_Lock) { _Impl = value; } }
    }
}