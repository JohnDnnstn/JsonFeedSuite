using GenericJsonSuite.EtlaToolbelt.Infrastructure;
using GenericJsonSuite.EtlaToolbelt.Logs;
using System.Runtime.CompilerServices;

// --------------------------------------------------------------------------------------------------
//	This code was generated by the ETLA Toolbelt Wizard version 1.0.59.11
//	Generated date: 2021-Mar-04 16:30:31
//
//	Changes to this file will be lost if the code is regenerated.
//	To make changes or additions, rerun the ETLA Toolbelt Wizard after editing T4 templates if required
// --------------------------------------------------------------------------------------------------

namespace GenericJsonSuite.EtlaToolbelt;

/// <summary>Provides logging-related utilties where the caller does not have to know anything about the actual implementation
/// The methods should never throw.
/// The precise algorithm depends on the implemetation 
/// The logging locations depend on the which ILogSinks have been added to the implementation's Sinks list
/// See <see cref="_Log"/> for the default implementation and the default LogSink it contains
/// 
/// Note:
/// At the time of writing... 
/// The default Sink contains onde default FileSink
/// The default location for the file written to is in the user's local AppData directory in a Context.App sub-directory
/// However it is advisable to check this.
/// </summary>

public abstract class Log : Fascia<ILog, _Log>
{
    /// <summary>Unique identifier for this instance of this application</summary>
    public static Guid Guid { get; set; } = Guid.NewGuid();

    /// <summary>Logs a message relating to a fatal error
    /// The system sleeps for 10 milliseconds before trying to log this message in order to increase the probability that previous messages have finished logging
    /// The method itself then waits until all the sinks have finished logging the message before returning.
    /// </summary>
    /// <param name="msg">A message to log relating to this error</param>
    /// <param name="e">Optional.  Any exception that has been caught.  Default null.</param>
    /// <param name="caller">Optional/Automatic.  The method that called this method.</param>
    /// <param name="path">Optional/Automatic.  The file containing the method that called this method.</param>
    /// <param name="line">Optional/Automatic.  The line in the file containing the method that called this method.</param>
    public static void Fatal(string msg, Exception? e = null,
        [CallerMemberName] string? caller = null, [CallerFilePath] string? path = null, [CallerLineNumber] int line = 0
        )
    {
        Thread.Sleep(10);
        Msg(LogLevel.FATAL, msg, e, caller, path, line, true);
    }

    /// <summary>Logs a message relating to a non-fatal error
    /// The method returns as soon as possible (without guaranteeing that the message has actually been logged) 
    /// </summary>
    /// <param name="msg">A message to log relating to this error</param>
    /// <param name="e">Optional.  Any exception that has been caught.  Default null.</param>
    /// <param name="caller">Optional/Automatic.  The method that called this method.</param>
    /// <param name="path">Optional/Automatic.  The file containing the method that called this method.</param>
    /// <param name="line">Optional/Automatic.  The line in the file containing the method that called this method.</param>		
    public static void Error(string msg, Exception? e = null,
		[CallerMemberName] string? caller = null, [CallerFilePath] string? path = null, [CallerLineNumber] int line = 0
        )
    {
        Msg(LogLevel.ERROR, msg, e, caller, path, line);
    }

    /// <summary>Logs a warning message
    /// The method returns as soon as possible (without guaranteeing that the message has actually been logged) 
    /// </summary>
    /// <param name="msg">A message to log relating to this warning</param>
    /// <param name="e">Optional.  Any exception that has been caught.  Default null.</param>
    /// <param name="caller">Optional/Automatic.  The method that called this method.</param>
    /// <param name="path">Optional/Automatic.  The file containing the method that called this method.</param>
    /// <param name="line">Optional/Automatic.  The line in the file containing the method that called this method.</param>		
    public static void Warn(string msg, Exception? e = null,
        [CallerMemberName] string? caller = null, [CallerFilePath] string? path = null, [CallerLineNumber] int line = 0
        )
    {
        Msg(LogLevel.WARN, msg, e, caller, path, line);
    }

    /// <summary>Logs an informational message
    /// The method returns as soon as possible (without guaranteeing that the message has actually been logged) 
    /// </summary>
    /// <param name="msg">A message to log relating to this information</param>
    /// <param name="e">Optional.  Any exception that has been caught.  Default null.</param>
    /// <param name="caller">Optional/Automatic.  The method that called this method.</param>
    /// <param name="path">Optional/Automatic.  The file containing the method that called this method.</param>
    /// <param name="line">Optional/Automatic.  The line in the file containing the method that called this method.</param>		
    public static void Info(string msg, Exception? e = null,
        [CallerMemberName] string? caller = null, [CallerFilePath] string? path = null, [CallerLineNumber] int line = 0
        )
    {
        Msg(LogLevel.INFO, msg, e, caller, path, line);
    }

    /// <summary>Logs a debugging message
    /// The method returns as soon as possible (without guaranteeing that the message has actually been logged) 
    /// </summary>
    /// <param name="msg">A message to log relating to this debugging message</param>
    /// <param name="e">Optional.  Any exception that has been caught.  Default null.</param>
    /// <param name="caller">Optional/Automatic.  The method that called this method.</param>
    /// <param name="path">Optional/Automatic.  The file containing the method that called this method.</param>
    /// <param name="line">Optional/Automatic.  The line in the file containing the method that called this method.</param>	
    public static void Debug(string msg, Exception? e = null,
        [CallerMemberName] string? caller = null, [CallerFilePath] string? path = null, [CallerLineNumber] int line = 0
        )
    {
        Msg(LogLevel.DEBUG, msg, e, caller, path, line);
    }

    /// <summary>Logs the start of application (strictly the start of logging)
    /// The method returns only when all the sinks have finished logging the message
    /// </summary>
    /// <param name="msg">A message to log relating to this</param>
    /// <param name="e">Optional.  Any exception that has been caught.  Default null.</param>
    /// <param name="caller">Optional/Automatic.  The method that called this method.</param>
    /// <param name="path">Optional/Automatic.  The file containing the method that called this method.</param>
    /// <param name="line">Optional/Automatic.  The line in the file containing the method that called this method.</param>			
    public static void Start(string? msg = null, Exception? e = null,
        [CallerMemberName] string? caller = null, [CallerFilePath] string? path = null, [CallerLineNumber] int line = 0
        )
    {
        //Trace.WriteLine(msg);
        Msg(LogLevel.START, msg, e, caller, path, line, true);
    }

    /// <summary>Logs the application finishing (in the exit event handler)
    /// The system sleeps for 10 milliseconds before trying to log this message in order to increase the probability that previous messages have finished logging
    /// The method itself then waits until all the sinks have finished logging the message before returning.
    /// </summary>
    /// <param name="msg">A message to log relating to this</param>
    /// <param name="e">Optional.  Any exception that has been caught.  Default null.</param>
    /// <param name="caller">Optional/Automatic.  The method that called this method.</param>
    /// <param name="path">Optional/Automatic.  The file containing the method that called this method.</param>
    /// <param name="line">Optional/Automatic.  The line in the file containing the method that called this method.</param>			
    public static void Finish(string? msg = null, Exception? e = null,
        [CallerMemberName] string? caller = null, [CallerFilePath] string? path = null, [CallerLineNumber] int line = 0
        )
    {
        Thread.Sleep(10);
        Msg(LogLevel.FINISH, msg, e, caller, path, line, true);
    }

    /// <summary>Logs the message in an Exception (as an error) before returning it (designed to record an exception before throwing/rethrowing)
    /// This allows the pattern:
    ///		throw Log.Exception(new Exception("my message"));
    ///	rather than
    ///		var msg = "my message";
    ///		Log.Error(msg);
    ///		throw new Exception(msg);
    /// The method itself then waits until all the sinks have finished logging the message before returning.
    /// </summary>
    /// <param name="e">The exception whose exception message is to be logged.</param>
    /// <param name="caller">Optional/Automatic.  The method that called this method.</param>
    /// <param name="path">Optional/Automatic.  The file containing the method that called this method.</param>
    /// <param name="line">Optional/Automatic.  The line in the file containing the method that called this method.</param>	
    /// <returns></returns>
    public static Exception Exception(Exception e,
        [CallerMemberName] string? caller = null, [CallerFilePath] string? path = null, [CallerLineNumber] int line = 0)
    {
        Msg(LogLevel.ERROR, e.Message, null, caller, path, line, true);
        return e;
    }

    /// <summary>The list of target logging systems to which log messages go</summary>
    public static IList<ILogSink> Sinks => Implementation.Sinks;

    /// <summary>Common method to  call the implementation to send it to the logging sinks (targets)</summary>
    /// <param name="level">How important this message is.  Different targets may only log messages with a certain importance</param>
    /// <param name="msg">The user message</param>
    /// <param name="e">Any associated exception</param>
    /// <param name="caller">The method that called the Logging system</param>
    /// <param name="path">The file containing the method that called the Logging system</param>
    /// <param name="line">The line in the file containing the method that called the Logging system</param>
    /// <param name="wait">Whether the the method returns immediately or after the message has been sent to all the sinks</param>
    /// <param name="guid">A unique identifier for this instance of the system</param>
    private static void Msg(LogLevel level, string? msg, Exception? e, string? caller, string? path, int line, bool wait = false, Guid? guid = null)
    {
        try
        {
            var logMessage = new LogMessage { Level = level, Msg = msg, E = e, Caller = caller, Path = path, Line = line, MsgGuid = guid };
            Implementation.Msg(logMessage, wait);
        }
        catch (Exception ex)
        {
            IgnoreExceptInDev(ex);
        }
    }

    /// <summary>Eats an exception unless we are in the DEV environment
    /// Designed to alert the developer to an issue but which is probably ignorable in a production system.
    /// See EtlaToolbelt.Contexts
    /// </summary>
    /// <param name="e">The exception to swallow</param>
    public static void IgnoreExceptInDev(Exception e)
    {
        System.Diagnostics.Debug.WriteLine(e);
        if (Context.IsDev())
        {
            throw e;
        }
    }
}