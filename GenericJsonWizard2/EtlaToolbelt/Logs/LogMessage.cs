/*
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Xml.Linq;
*/

// --------------------------------------------------------------------------------------------------
// <auto-generated>
//	This code was generated by the ETLA Toolbelt Wizard version 1.0.59.11
//	Generated date: 2021-Mar-04 16:30:31
//
//	Changes to this file will be lost if the code is regenerated.
//	To make changes or additions, rerun the ETLA Toolbelt Wizard after editing T4 templates if required
// </auto-generated>
#nullable enable
// --------------------------------------------------------------------------------------------------

namespace GenericJsonSuite.EtlaToolbelt.Logs
{
    /// <summary>Defines the various elements of a log message (not just its text), e.g. when the message was created</summary>
    public class LogMessage
    {
        /// <summary>Provides a version number for the LogMessage structure being used
        /// This allows for changes to the structure and allows sinks to work out if they can handle a message
        /// </summary>
        public int? Version = 1;  // Change this if this class is amended so we can handle version changes

        /// <summary>What sort of message this is
        /// This allows sinks to ignore messages they are not interested in
        /// </summary>
        public LogLevel Level { get; set; }

        /// <summary>The text of the log message</summary>
        public string? Msg { get; set; } = "";

        /// <summary>An exception related to the log message (if any)</summary>
        internal Exception? E { get; set; }

        /// <summary>The text of a related exception (if any)</summary>
        public string Ex { get; set; } = "";

        /// <summary> When the log message was created</summary>
        public DateTime? Stamp { get; set; } = DateTime.Now;

        /// <summary>The method which called the log mechanism</summary>
        public string? Caller { get; set; } = "";

        /// <summary>The path of the source code of the method which called the log mechanism</summary>
        public string? Path { get; set; } = "";

        /// <summary>The line number in the source code where the log mechanism was invoked</summary>
        public int? Line { get; set; }

        /// <summary>A unique guid for each log message</summary>
        public Guid? MsgGuid { get; set; }

        /// <summary>A unique guid for this application instance 
        /// useful for sinks such as databases where multiple applications may be writing simultaneously
        /// </summary>
        public Guid? InstanceGuid { get; set; } = Log.Guid;

        /// <summary>A unique guid for this application</summary>
        public Guid? AppGuid { get; set; } = Context.AppGuid;

        /*
                public string ToXml()
                {
                    XElement root = new XElement("LogMessage");
                    root.Add(new XElement("Version", Version));
                    root.Add(new XElement("Level",Level));
                    root.Add(new XElement("Msg", Msg));
                    if (E != null) { root.Add(new XElement("Ex", FromException(E))); }
                    root.Add(new XElement("Stamp",Stamp));
                    root.Add(new XElement("Caller",Caller));
                    root.Add(new XElement("Path",Path));
                    if (Line != null) { root.Add(new XElement("Line", Line)); }
                    if (MsgGuid != null) { root.Add(new XElement("MsgGuid", MsgGuid)); }
                    if (InstanceGuid != null) { root.Add(new XElement("InstanceGuid", InstanceGuid)); }
                    if (AppGuid != null) { root.Add(new XElement("AppGuid", AppGuid)); }
                    return root.ToString();
                }

                public static LogMessage FromXml(string str)
                {
                    var answer = new LogMessage();
                    XDocument doc = XDocument.Parse(str);
                    var root = doc.Root;
                    answer.Version = (int?)root.Element("Version");
                    answer.Level = (LogLevel)Enum.Parse(answer.Level.GetType(),(string)root.Element("Level"));
                    answer.Msg = (string)root.Element("Msg");
                    answer.Ex = (string)root.Element("Ex");
                    answer.E = ToException(answer.Ex);
                    answer.Stamp = (DateTime?)root.Element("Stamp");
                    answer.Caller = (string)root.Element("Caller");
                    answer.Path = (string)root.Element("Path");
                    answer.Line = (int?)root.Element("Line");
                    answer.MsgGuid = (Guid?)root.Element("MsgGuid");
                    answer.InstanceGuid = (Guid?)root.Element("InstanceGuid");
                    answer.AppGuid = (Guid?)root.Element("AppGuid");
                    return answer;
                }

                public static string FromException(Exception ex)
                {
                    if (ex == null) { return null; }
                    using (var stream = new MemoryStream())
                    {
                        try
                        {
                            var formatter = new BinaryFormatter();
                            formatter.Serialize(stream, ex);
                            stream.Position = 0;
                            return Convert.ToBase64String(stream.ToArray());
                        }
                        catch (Exception e)
                        {
                            Log.IgnoreExceptInDev(e);
                            return null;
                        }
                    }
                }

                public static Exception ToException(string str)
                {
                    if (string.IsNullOrWhiteSpace(str)) { return null; }
                    try
                    {
                        byte[] bytes = Convert.FromBase64String(str);
                        using (var stream = new MemoryStream(bytes))
                        {
                            var formatter = new BinaryFormatter();
                            var answer = (Exception)formatter.Deserialize(stream);
                            return answer;
                        }
                    }
                    catch (Exception e)
                    {
                        Log.IgnoreExceptInDev(e);
                        return null;
                    }

                }
        */
    }
}